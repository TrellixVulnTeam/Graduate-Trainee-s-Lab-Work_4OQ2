<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    1Q:What is callback function and callback hell in javascript?
    Ans:Callback: A callback is a function that is passed as an argument to another function that executes the callback based on the result. 
    They are basically functions that are executed only after a result is produced. Callbacks are an important part of asynchronous JavaScript.

    Ex:
    // Main function
const mainFunction = (callback) => {
    setTimeout(() => {
        callback([2, 3, 4]);
    }, 2000)
}
  
// Add function
const add = (array) => {
    let sum = 0;
    for(let i of array) {
        sum += i;
    }
    console.log(sum);
}
  
// Calling main function
mainFunction(add);

    Callback Hell:Callback Hell is essentially nested callbacks stacked below one another forming a pyramid structure.
    Every callback depends/waits for the previous callback, thereby making a pyramid structure that affects the readability and maintainability of the code.

Ex:
<script>
    let words = document.querySelectorAll(".word");
  
    const animateAll = (animate) => {
        setTimeout(() => {
            animate(words[0]);
            setTimeout(() => {
                animate(words[1]);
                setTimeout(() => {
                    animate(words[2]);
                }, 1000)
            }, 1000)
        }, 1000)
    }
  
    const animate = (word) => {
        word.classList.add("animate");
    }
  
    animateAll(animate);
</script>


    2Q:Explain how to iterate an object in javascript? 
    Ans:The Object.keys() method returns an array of a given object's own enumerable property names, iterated in the same order that a normal loop would.

    const data = {
        name: 'John',
        dob: '15-08-1997',
        address: '#123 mg road hyderabad telangana'
    }
    
    Object.keys(data).forEach(key => {
        console.log(key, data[key])
    });

    3Q:Explain about promises and create a custom promise with simple example?
    Ans:A Promise is a proxy for a value not necessarily known when the promise is created. 
    It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. 
    This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

    A Promise is in one of these states:
    
    pending: initial state, neither fulfilled nor rejected.
    fulfilled: meaning that the operation was completed successfully.
    rejected: meaning that the operation failed.
    The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.
    
    let myPromise = new Promise(function(myResolve, myReject) {
      let x = 0;
    
    // The producing code (this may take some time)
    
      if (x == 0) {
        myResolve("OK");
      } else {
        myReject("Error");
      }
    });
    
    myPromise.then(
      function(value) {myDisplayer(value);},
      function(error) {myDisplayer(error);}
    );

    4Q:What is implicit type conversion in javascript?
    4 ans:Type conversion (or typecasting) means transfer of data from one data type to another. 
    Implicit conversion happens when the compiler (for compiled languages) or runtime (for script languages like JavaScript) automatically converts data types. 
    The source code can also explicitly require a conversion to take place.

    Ex:
    let result;

result = '5' + 6;
console.log(result) // "56"

result = '9' + true;
console.log(result); // "9true"

result = '3' + undefined;
console.log(result); // "3undefined"

result = '5' + null;
console.log(result); // "5null"

When a number is added to a string, JavaScript converts the number to a string before concatenation.

Ex:

let result;

result = '6' - '2';
console.log(result); // 4

result = '5' - 2;
console.log(result); // 3

result = '9' * 2;
console.log(result); // 18

result = '8' / 2;
console.log(result); // 4



    5Q:Explain passed by value and passed by reference in javascript?
    Ans:Pass By Value: In Pass by value, function is called by directly passing the value of the variable as an argument. 
    So any changes made inside the function does not affect the original value.

    In Pass by value, parameters passed as an arguments create its own copy. 
    So any changes made inside the function is made to the copied value not to the original value.

    Ex:
        function callByValue(varOne, varTwo) {
        console.log("Inside Call by Value Method");
        varOne = 100;
        varTwo = 200;
        console.log("varOne =" + varOne +"varTwo =" +varTwo);
        }
        let varOne = 10;
        let varTwo = 20;
        console.log("Before Call by Value Method");
        console.log("varOne =" + varOne +"varTwo =" +varTwo);
        callByValue(varOne, varTwo)
        console.log("After Call by Value Method");
        console.log("varOne =" + varOne +"varTwo =" +varTwo);
        
    
    Pass by Reference: In Pass by Reference, Function is called by directly passing the reference/address of the variable as an argument. 
    So changing the value inside the function also change the original value. In JavaScript array and Object follows pass by reference property.
    
    In Pass by reference, parameters passed as an arguments does not create its own copy, it refers to the original value so changes made inside function affect the original value.

    Ex:
        function callByReference(varObj) {
        console.log("Inside Call by Reference Method");
        varObj.a = 100;
        console.log(varObj);
        }
        let varObj = {a:1};
        console.log("Before Call by Reference Method");
        console.log(varObj);
        callByReference(varObj)
        console.log("After Call by Reference Method");
        console.log(varObj);

    6Q:What is difference between flex and css grid explain with example?
    Ans:Uniqueness In Grid And Flexbox:

    One Vs Two Dimension:
    
    Grid is made for two-dimensional layout while Flexbox is for one. This means Flexbox can work on either row or columns at a time, but Grids can work on both.
    Flexbox, gives you more flexibility while working on either element (row or column). HTML markup and CSS will be easy to manage in this type of scenario.
    GRID gives you more flexibility to move around the blocks irrespective of your HTML markup.
    Content-First vs Layout-First:
    
    Major Uniqueness between Flexbox and Grids is that the former works on content while the latter is based on the layout.
    The Flexbox layout is best suited to application components and small-scale layouts, while the Grid layout is designed for larger-scale layouts that are not linear in design.

    Difference Between Grid and Flexbox:
    
    1. Dimensionality and Flexibility:
    
    Flexbox offers greater control over alignment and space distribution between items. Being one-dimensional, Flexbox only deals with either columns or rows.
    Grid has two-dimension layout capabilities which allow flexible widths as a unit of length. This compensates for the limitations in Flex.

    2. Alignment:
    
    Flex Direction allows developers to align elements vertically or horizontally, which is used when developers create and reverse rows or columns.
    CSS Grid deploys fractional measure units for grid fluidity and auto-keyword functionality to automatically adjust columns or rows.

    3. Item Management:
    
    Flex Container is the parent element while Flex Item represents the children. The Flex Container can ensure balanced representation by adjusting item dimensions. This allows developers to design for fluctuating screen sizes.
    Grid supports both implicit and explicit content placement. Its inbuilt automation allows it to automatically extend line items and copy values into the new creation from the preceding item.
    
    Conclusion:
    
    CSS Grids helps you create the outer layout of the webpage. You can build complex as well responsive design with this. This is why it is called ‘layout first’.
    Flexbox mostly helps align content & move blocks.
    CSS grids are for 2D layouts. It works with both rows and columns.
    Flexbox works better in one dimension only (either rows OR columns).
    It will be more time saving and helpful if you use both at the same time.

    
    7Q:Explain about currying with example?
    Ans:It is a technique in functional programming, transformation of the function of multiple arguments into several functions of a single argument in sequence. 
    We simply wrap function inside a function, which means we are going to return a function from another function to obtain this kind of translation. 
    The parent function takes the first provided argument and returns the function that takes the next argument and this keeps on repeating till the number of arguments ends.

    Ex:Let’s say we have the length, breadth, and height of a cuboid and we want to construct a function that can calculate the volume. 
    The function is being called which consequently executes its code by provided arguments and returns the appropriate result. 
    FInally console.log prints the returned value on console.

    <script>
        function calculateVolume(length, breadth, height) {
            return length * breadth * height;
        }
        console.log(calculateVolume(4, 5, 6));
    </script>


    8Q:Explain about object prototype and add reverse method to string class to reverse a given string?
    Ans:All JavaScript objects inherit properties and methods from a prototype.
    Prototype Inheritance
    All JavaScript objects inherit properties and methods from a prototype:
    
    Date objects inherit from Date.prototype
    Array objects inherit from Array.prototype
    Person objects inherit from Person.prototype
    The Object.prototype is on the top of the prototype inheritance chain:
    
    Date objects, Array objects, and Person objects inherit from Object.prototype.
    
    Ex: 
    function Person(first, last, age, eyecolor) {
      this.firstName = first;
      this.lastName = last;
      this.age = age;
      this.eyeColor = eyecolor;
    }
    
    Person.prototype.nationality = "English";

    Reverse of a string:
    <script>
        var str = "MOUNIKA";
         console.log(str);
 
         var output = str.split('').reverse().join('');
         console.log(output);
    </script>

    9Q:What are the differences between javascript and typescript?
    Ans:Features of TypeScript:

    TypeScript Code is converted into Plain JavaScript Code.TypeScript code can’t be natively interpreted by browsers. 
    So if the code was written in TypeScript, it gets compiled and converted into JavaScript. 
    This process is known as Trans-piled. With the help of JavaScript code, browsers are able to read the code and display it.
    JavaScript is TypeScript: Whatever code is written in JavaScript can be converted to TypeScript by changing the extension from .js to .ts.
    Use TypeScript anywhere: TypeScript can be compiled to run on any browser, device, or operating system. TypeScript is not specific to any single environment.
    TypeScript supports JS libraries: With TypeScript, developers can use already existing JavaScript code, incorporate popular JavaScript libraries, or call the TS Code from native JavaScript code.

    Difference between TypeScript and JavaScript:
    
    TypeScript is known as an Object-oriented programming language whereas JavaScript is a prototype based language.
    TypeScript has a feature known as Static typing but JavaScript does not support this feature.
    TypeScript supports Interfaces but JavaScript does not.

    Advantages of using TypeScript over JavaScript:
    
    TypeScript always points out the compilation errors at the time of development (pre-compilation). 
    Because of this getting runtime errors is less likely, whereas JavaScript is an interpreted language.
    TypeScript supports static/strong typing. This means that type correctness can be checked at compile time. 
    This feature is not available in JavaScript.
    TypeScript is nothing but JavaScript and some additional features i.e. ES6 features. 
    It may not be supported in your target browser but the TypeScript compiler can compile the .ts files into ES3, ES4, and ES5 also.

    Disadvantages of using TypeScript over JavaScript:
     Generally, TypeScript takes time to compile the code.

     10Q:How to access data from one script block to another script block in javascript?
     Ans:At first the “module1.js” file is created and a Student object with properties “name”, “age”, “dept” and “score” is defined. 
     The module1.js JavaScript file is imported using the src attribute of script tag within the “head” section of the HTML file. Since the JavaScript file is imported, the contents are accessible within the HTML file.

     We create a button which when clicked triggers the JavaScript function. The Student object properties are accessed through the f() function and all the Student object properties are concatenated to a string variable. 
     This string is placed within the <p> tag having ‘text’ id using the document.getElementById() and innerHTML property of HTML DOM. This is an example of a client side program.
     
     variable_access.html
     <!DOCTYPE html>
     <html>
     
     <head>
         <script type="text/javascript"
             src="module1.js">
         </script>
     </head>
     
     <body>
         <button onclick="f()">
             Click Me To Get Student Details
         </button>
     
         <div>
             <p id="text" style="color:purple;
                 font-weight:bold;font-size:20px;">
             </p>
         </div>
     
         <script type="text/javascript">
             function f() {
                 var name = Student.name;
                 var age = Student.age;
                 var dept = Student.dept;
                 var score = Student.score;
     
                 var str = "Name:" + name + "\nAge: "
                     + age + "\nDepartment:" + dept
                     + "\nScore: " + score;
     
                 document.getElementById(
                     'text').innerHTML = str;
             }
         </script>
     </body>
     
     </html>
     
     module1.js This file is used in the above HTML code.
     
     var Student =
     {
         name : "ABC",
         age : 18,
         dept : "CSE",
         score : 90
     };



    
</body>
</html>